<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法概述</title>
    <url>/2020/12/01/all_algo/</url>
    <content><![CDATA[<p>最近对“算法”有了新的理解，对于普通程序员来说，算法功底的好坏对于简洁而高质量的代码至关重要，因此决定从一些经典的ACM算法开始，扎实的学习一下这些算法和编程技巧，以期能有更好的将来。从网上搜索了一些资料，发现“@制糕神的算法工坊”整理的比较全面，这里借用他的一张图片，后续将从他的这个图片开始学习。</p>
<p><img src="/2020/12/01/all_algo/algo.jpeg" alt="图1 算法分类"><span class="image-caption">图1 算法分类</span></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.zhihu.com/question/332733219/answer/878129865">https://www.zhihu.com/question/332733219/answer/878129865</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>all algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化</title>
    <url>/2020/12/06/convex_optimization/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$$ min \ f_{0}(x) $$<br>$$ subject \ to \ f_{i}(x) \leqslant b_{i} \ i=1,…,m $$</p>
<ul>
<li>目标函数和限制函数都是凸的，即<br>$$ f_{i}(\alpha x + \beta y) \leqslant \alpha f_{i}(x) + \beta f_{i}(y) \ \alpha + \beta = 1, \alpha \geq 0, \beta \geq 0 $$</li>
<li>最小二乘问题和线性规划问题都是凸优化问题的特例</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>没有解析解</li>
<li>但是有可靠和高效的求解算法</li>
<li>计算时间复杂度大体上和$max(n^{3}, n^{2}m, F)$成正比，其中$F$是计算$f_{i}$和它的一阶导，二阶导的开销</li>
</ol>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>每一个局部最优解都是全局最优解</li>
<li>最优解集合是凸的</li>
<li>如果目标函数是严格凸的，那么这个优化问题就最多只有一个最优解</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>一般不容易分析出问题的凸优化形式</li>
<li>需要很多技巧才能将问题转换成凸优化问题</li>
<li>会对很多问题能够凸优化求解感到惊奇</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>Standford Boyd, Convex Optimization course, <a href="https://web.stanford.edu/~boyd/cvxbook/">https://web.stanford.edu/~boyd/cvxbook/</a></li>
<li>Standford Boyd, Convex Optimization <a href="/2020/12/06/convex_optimization/bv_cvxslides.pdf">slides</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>convex optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>爬山算法</title>
    <url>/2020/12/12/hill_climbing/</url>
    <content><![CDATA[<p>爬山算法是一种局部择优的方法，采用启发式方法，是对深度优先搜索的一种改进，它利用反馈信息帮助生成解的决策。</p>
<p>爬山算法一般存在以下问题：</p>
<ol>
<li>局部最大</li>
<li>高地：也称为平顶，搜索一旦到达高地，就无法确定搜索最佳方向，会产生随机走动，使得搜索效率降低。</li>
<li>山脊：搜索可能会在山脊的两面来回震荡，前进步伐很小。</li>
</ol>
<p>对于离散问题，我们从当前解出发，找到最佳的邻居进行下一步的迭代；对于连续空间的问题，我们对于每一个分量按照一定的步长进行探索，如果找到了更优的邻居，我们更新下一轮的步长为当前的最优步长；否则我们减小步长。下面我们尝试使用爬山算法来解决<a href="https://leehengtong.com/2020/12/07/optimization_problem/">上篇文章</a>中的几个问题：</p>
<h2 id="问题1-离散空间优化问题"><a href="#问题1-离散空间优化问题" class="headerlink" title="问题1: 离散空间优化问题"></a>问题1: 离散空间优化问题</h2><p>我们使用以下程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neighbor</span>(<span class="params">last</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    returns all neighbors</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        cur = []</span><br><span class="line">        <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(last):</span><br><span class="line">            <span class="keyword">if</span> j == i:</span><br><span class="line">                n = <span class="number">1</span> - n</span><br><span class="line">            cur.append(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">T, M, t, m</span>):</span></span><br><span class="line">    <span class="comment"># compute used time</span></span><br><span class="line">    time = <span class="keyword">lambda</span> cur: <span class="built_in">sum</span>([cur[i] * t[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M)])</span><br><span class="line">    <span class="comment"># compute the value got</span></span><br><span class="line">    value = <span class="keyword">lambda</span> cur: <span class="built_in">sum</span>([cur[i] * m[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M)])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># valid init solution</span></span><br><span class="line">    ans = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    update = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> update:</span><br><span class="line">        update = <span class="literal">False</span></span><br><span class="line">        ans_time = time(ans)</span><br><span class="line">        ans_value = value(ans)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> neighbor(ans):</span><br><span class="line">            cur_time = time(cur)</span><br><span class="line">            cur_value = value(cur)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_time &lt;= T <span class="keyword">and</span> cur_value &gt; ans_value:</span><br><span class="line">                ans = cur</span><br><span class="line">                update = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    print(ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    T = <span class="number">70</span></span><br><span class="line">    M = <span class="number">3</span></span><br><span class="line">    t = [<span class="number">71</span>, <span class="number">69</span>, <span class="number">1</span>]</span><br><span class="line">    m = [<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    solve(T, M, t, m)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0, 1, 1]</span><br></pre></td></tr></table></figure>


<h2 id="问题2-连续空间多变量多约束非线性规划问题"><a href="#问题2-连续空间多变量多约束非线性规划问题" class="headerlink" title="问题2: 连续空间多变量多约束非线性规划问题"></a>问题2: 连续空间多变量多约束非线性规划问题</h2><p>我们使用以下程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    the target function</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> math.exp(</span><br><span class="line">        x[<span class="number">0</span>]) * (<span class="number">4</span> * x[<span class="number">0</span>]**<span class="number">2</span> + <span class="number">2</span> * x[<span class="number">1</span>]**<span class="number">2</span> + <span class="number">4</span> * x[<span class="number">0</span>] * x[<span class="number">1</span>] + <span class="number">2</span> * x[<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    check the constraint</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">6</span> <span class="keyword">or</span> i &lt; -<span class="number">6</span> <span class="keyword">or</span> i &gt; <span class="number">10</span> <span class="keyword">or</span> i &lt; -<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> -x[<span class="number">0</span>] * x[<span class="number">1</span>] &gt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1.5</span> + x[<span class="number">0</span>] * x[<span class="number">1</span>] - x[<span class="number">0</span>] - x[<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>():</span></span><br><span class="line">    step = [<span class="number">0.1</span>, <span class="number">0.1</span>]</span><br><span class="line">    accel = <span class="number">1.2</span></span><br><span class="line">    candi = [-accel, -<span class="number">1</span> / accel, <span class="number">1</span> / accel, accel]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># valid init solution</span></span><br><span class="line">    cur_ans = [<span class="number">0</span>, <span class="number">5</span>]</span><br><span class="line">    best_val = func(cur_ans)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">        before_val = best_val</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(cur_ans):</span><br><span class="line">            before_ans = copy.deepcopy(cur_ans)</span><br><span class="line">            best_step = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> candi:</span><br><span class="line">                cur_step = step[i] * c</span><br><span class="line">                cur_ans[i] = before_ans[i] + cur_step</span><br><span class="line">                <span class="keyword">if</span> constrain(cur_ans):</span><br><span class="line">                    cur_val = func(cur_ans)</span><br><span class="line">                    <span class="keyword">if</span> cur_val &lt; best_val:</span><br><span class="line">                        print(</span><br><span class="line">                            <span class="string">&quot;update &#123;0&#125;th by step &#123;1&#125;, current ans: &#123;2&#125;, current val: &#123;3&#125;)&quot;</span></span><br><span class="line">                            .<span class="built_in">format</span>(i, cur_step, cur_ans, cur_val))</span><br><span class="line">                        best_val = cur_val</span><br><span class="line">                        best_step = cur_step</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> best_step == <span class="number">0</span>:</span><br><span class="line">                step[i] = step[i] / accel</span><br><span class="line">                cur_ans[i] = before_ans[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                step[i] = best_step</span><br><span class="line">                cur_ans[i] = before_ans[i] + best_step</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;iteration &#123;0&#125;: &#123;1&#125;, &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(k, cur_ans, best_val))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(best_val - before_val) &lt; <span class="number">1e-16</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(cur_ans)</span><br><span class="line">    print(func(cur_ans))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 0th by step -0.12, current ans: [-0.12, 5], current val: 52.02462420878034)</span><br><span class="line">update 1th by step -0.12, current ans: [-0.12, 4.88], current val: 49.759784181579406)</span><br><span class="line">iteration 1: [-0.12, 4.88], 49.759784181579406</span><br><span class="line">update 0th by step -0.1, current ans: [-0.22, 4.88], current val: 43.56714050378704)</span><br><span class="line">update 0th by step -0.144, current ans: [-0.264, 4.88], current val: 41.09756946514502)</span><br><span class="line">update 1th by step -0.1, current ans: [-0.264, 4.78], current val: 39.541347884384685)</span><br><span class="line">update 1th by step -0.144, current ans: [-0.264, 4.736], current val: 38.86634214954465)</span><br><span class="line">iteration 2: [-0.264, 4.736], 38.86634214954465</span><br><span class="line">update 0th by step -0.12, current ans: [-0.384, 4.736], current val: 33.13480982120382)</span><br><span class="line">update 0th by step -0.17279999999999998, current ans: [-0.43679999999999997, 4.736], current val: 30.896422546501622)</span><br><span class="line">update 1th by step -0.12, current ans: [-0.43679999999999997, 4.616], current val: 29.426662476165006)</span><br><span class="line">update 1th by step -0.17279999999999998, current ans: [-0.43679999999999997, 4.5632], current val: 28.79175788291818)</span><br><span class="line">iteration 3: [-0.43679999999999997, 4.5632], 28.79175788291818</span><br><span class="line">update 0th by step -0.144, current ans: [-0.5808, 4.5632], current val: 23.787883625501976)</span><br><span class="line">update 0th by step -0.20735999999999996, current ans: [-0.64416, 4.5632], current val: 21.883178378702226)</span><br><span class="line">update 1th by step -0.144, current ans: [-0.64416, 4.4192], current val: 20.56837447029764)</span><br><span class="line">update 1th by step -0.20735999999999996, current ans: [-0.64416, 4.355840000000001], current val: 20.00365871483697)</span><br><span class="line">iteration 4: [-0.64416, 4.355840000000001], 20.00365871483697</span><br><span class="line">update 0th by step -0.17279999999999998, current ans: [-0.8169599999999999, 4.355840000000001], current val: 15.945283197922732)</span><br><span class="line">update 0th by step -0.24883199999999994, current ans: [-0.8929919999999999, 4.355840000000001], current val: 14.448411201985614)</span><br><span class="line">update 1th by step -0.17279999999999998, current ans: [-0.8929919999999999, 4.183040000000001], current val: 13.351387037399203)</span><br><span class="line">update 1th by step -0.24883199999999994, current ans: [-0.8929919999999999, 4.107008], current val: 12.884188535334253)</span><br><span class="line">iteration 5: [-0.8929919999999999, 4.107008], 12.884188535334253</span><br><span class="line">update 0th by step -0.20735999999999996, current ans: [-1.1003519999999998, 4.107008], current val: 9.887958052713891)</span><br><span class="line">update 0th by step -0.29859839999999993, current ans: [-1.1915904, 4.107008], current val: 8.824528435241017)</span><br><span class="line">update 1th by step -0.20735999999999996, current ans: [-1.1915904, 3.8996480000000004], current val: 7.990194786653624)</span><br><span class="line">update 1th by step -0.29859839999999993, current ans: [-1.1915904, 3.8084096000000005], current val: 7.639637828810663)</span><br><span class="line">iteration 6: [-1.1915904, 3.8084096000000005], 7.639637828810663</span><br><span class="line">update 0th by step -0.24883199999999994, current ans: [-1.4404223999999999, 3.8084096000000005], current val: 5.679407582979268)</span><br><span class="line">update 0th by step -0.3583180799999999, current ans: [-1.5499084799999998, 3.8084096000000005], current val: 5.0143729160083135)</span><br><span class="line">update 1th by step -0.24883199999999994, current ans: [-1.5499084799999998, 3.559577600000001], current val: 4.457854774352143)</span><br><span class="line">update 1th by step -0.3583180799999999, current ans: [-1.5499084799999998, 3.4500915200000004], current val: 4.229641649646535)</span><br><span class="line">iteration 7: [-1.5499084799999998, 3.4500915200000004], 4.229641649646535</span><br><span class="line">update 0th by step -0.29859839999999993, current ans: [-1.8485068799999997, 3.4500915200000004], current val: 3.128071004768359)</span><br><span class="line">update 0th by step -0.4299816959999999, current ans: [-1.9798901759999996, 3.4500915200000004], current val: 2.7704007740632144)</span><br><span class="line">update 1th by step -0.29859839999999993, current ans: [-1.9798901759999996, 3.1514931200000005], current val: 2.470084617885889)</span><br><span class="line">update 1th by step -0.4299816959999999, current ans: [-1.9798901759999996, 3.0201098240000004], current val: 2.3535469510854665)</span><br><span class="line">iteration 8: [-1.9798901759999996, 3.0201098240000004], 2.3535469510854665</span><br><span class="line">update 0th by step -0.3583180799999999, current ans: [-2.3382082559999997, 3.0201098240000004], current val: 1.8243045861337608)</span><br><span class="line">update 0th by step -0.5159780351999999, current ans: [-2.4958682111999995, 3.0201098240000004], current val: 1.6525025525118668)</span><br><span class="line">update 1th by step -0.3583180799999999, current ans: [-2.4958682111999995, 2.6617917440000003], current val: 1.5526668064303875)</span><br><span class="line">update 1th by step -0.5159780351999999, current ans: [-2.4958682111999995, 2.5041317888000005], current val: 1.5221494499076038)</span><br><span class="line">iteration 9: [-2.4958682111999995, 2.5041317888000005], 1.5221494499076038</span><br><span class="line">update 0th by step -0.4299816959999999, current ans: [-2.9258499071999995, 2.5041317888000005], current val: 1.2592527050521631)</span><br><span class="line">update 0th by step -0.6191736422399998, current ans: [-3.1150418534399993, 2.5041317888000005], current val: 1.160966703528361)</span><br><span class="line">iteration 10: [-3.1150418534399993, 2.5041317888000005], 1.160966703528361</span><br><span class="line">update 0th by step -0.5159780351999999, current ans: [-3.631019888639999, 2.5041317888000005], current val: 0.9249119591204455)</span><br><span class="line">update 0th by step -0.7430083706879997, current ans: [-3.8580502241279993, 2.5041317888000005], current val: 0.8326186761463709)</span><br><span class="line">iteration 11: [-3.8580502241279993, 2.5041317888000005], 0.8326186761463709</span><br><span class="line">iteration 12: [-3.8580502241279993, 2.5041317888000005], 0.8326186761463709</span><br><span class="line">[-3.8580502241279993, 2.5041317888000005]</span><br><span class="line">0.8326186761463709</span><br></pre></td></tr></table></figure>




<h2 id="问题3-连续空间最值问题"><a href="#问题3-连续空间最值问题" class="headerlink" title="问题3: 连续空间最值问题"></a>问题3: 连续空间最值问题</h2><p>我们使用以下程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    the target function</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">200</span> * math.exp(-<span class="number">0.05</span> * x[<span class="number">0</span>]) * math.sin(x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    check the constraint</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] &gt;= -<span class="number">2</span> <span class="keyword">and</span> x[<span class="number">0</span>] &lt;= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>():</span></span><br><span class="line">    step = [<span class="number">0.1</span>]</span><br><span class="line">    accel = <span class="number">1.2</span></span><br><span class="line">    candi = [-accel, -<span class="number">1</span> / accel, <span class="number">1</span> / accel, accel]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># valid init solution</span></span><br><span class="line">    cur_ans = [<span class="number">0</span>]</span><br><span class="line">    best_val = func(cur_ans)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">        before_val = best_val</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(cur_ans):</span><br><span class="line">            before_ans = copy.deepcopy(cur_ans)</span><br><span class="line">            best_step = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> candi:</span><br><span class="line">                cur_step = step[i] * c</span><br><span class="line">                cur_ans[i] = before_ans[i] + cur_step</span><br><span class="line">                <span class="keyword">if</span> constrain(cur_ans):</span><br><span class="line">                    cur_val = func(cur_ans)</span><br><span class="line">                    <span class="keyword">if</span> cur_val &lt; best_val:</span><br><span class="line">                        print(</span><br><span class="line">                            <span class="string">&quot;update &#123;0&#125;th by step &#123;1&#125;, current ans: &#123;2&#125;, current val: &#123;3&#125;)&quot;</span></span><br><span class="line">                            .<span class="built_in">format</span>(i, cur_step, cur_ans, cur_val))</span><br><span class="line">                        best_val = cur_val</span><br><span class="line">                        best_step = cur_step</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> best_step == <span class="number">0</span>:</span><br><span class="line">                step[i] = step[i] / accel</span><br><span class="line">                cur_ans[i] = before_ans[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                step[i] = best_step</span><br><span class="line">                cur_ans[i] = before_ans[i] + best_step</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;iteration &#123;0&#125;: &#123;1&#125;, &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(k, cur_ans, best_val))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(best_val - before_val) &lt; <span class="number">1e-16</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(cur_ans)</span><br><span class="line">    print(func(cur_ans))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 0th by step 0.08333333333333334, current ans: [0.08333333333333334], current val: -16.578163451266125)</span><br><span class="line">update 0th by step 0.12, current ans: [0.12], current val: -23.799216912346857)</span><br><span class="line">iteration 1: [0.12], -23.799216912346857</span><br><span class="line">update 0th by step 0.1, current ans: [0.22], current val: -43.16845036828165)</span><br><span class="line">update 0th by step 0.144, current ans: [0.264], current val: -51.5044434420067)</span><br><span class="line">iteration 2: [0.264], -51.5044434420067</span><br><span class="line">update 0th by step 0.12, current ans: [0.384], current val: -73.50156515472206)</span><br><span class="line">update 0th by step 0.17279999999999998, current ans: [0.43679999999999997], current val: -82.78060135028912)</span><br><span class="line">iteration 3: [0.43679999999999997], -82.78060135028912</span><br><span class="line">update 0th by step 0.144, current ans: [0.5808], current val: -106.59760552432024)</span><br><span class="line">update 0th by step 0.20735999999999996, current ans: [0.64416], current val: -116.29867444926786)</span><br><span class="line">iteration 4: [0.64416], -116.29867444926786</span><br><span class="line">update 0th by step 0.17279999999999998, current ans: [0.8169599999999999], current val: -139.97751214953558)</span><br><span class="line">update 0th by step 0.24883199999999994, current ans: [0.8929919999999999], current val: -148.98732425593082)</span><br><span class="line">iteration 5: [0.8929919999999999], -148.98732425593082</span><br><span class="line">update 0th by step 0.20735999999999996, current ans: [1.1003519999999998], current val: -168.73015014835786)</span><br><span class="line">update 0th by step 0.29859839999999993, current ans: [1.1915904], current val: -175.04569315355005)</span><br><span class="line">iteration 6: [1.1915904], -175.04569315355005</span><br><span class="line">update 0th by step 0.24883199999999994, current ans: [1.4404223999999999], current val: -184.52286412601495)</span><br><span class="line">update 0th by step 0.3583180799999999, current ans: [1.5499084799999998], current val: -185.04587653587126)</span><br><span class="line">iteration 7: [1.5499084799999998], -185.04587653587126</span><br><span class="line">iteration 8: [1.5499084799999998], -185.04587653587126</span><br><span class="line">[1.5499084799999998]</span><br><span class="line">-185.04587653587126</span><br></pre></td></tr></table></figure>


<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://oi-wiki.org/misc/hill-climbing/">https://oi-wiki.org/misc/hill-climbing/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hill_climbing">https://en.wikipedia.org/wiki/Hill_climbing</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>hill climbing</tag>
      </tags>
  </entry>
  <entry>
    <title>优化问题</title>
    <url>/2020/12/07/optimization_problem/</url>
    <content><![CDATA[<p>我们工作生活中的很多问题都是优化问题。在本文中，我们给出几个典型的例子，并尝试使用现有的求解器进行求解，作为参照。在后续文章中，我们将介绍一些启发式算法，并对本文中的问题进行求解。</p>
<h2 id="问题1-离散空间优化问题"><a href="#问题1-离散空间优化问题" class="headerlink" title="问题1: 离散空间优化问题"></a>问题1: 离散空间优化问题</h2><h3 id="luogu-P1048-采药"><a href="#luogu-P1048-采药" class="headerlink" title="luogu P1048 采药"></a><a href="https://www.luogu.com.cn/problem/P1048">luogu P1048 采药</a></h3><blockquote>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p>
<p>如果你是辰辰，你能完成这个任务吗？</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有 $2$ 个整数 $T$（$1 \le T \le 1000, \ 1 \le T \le 000$）和 $M$（$1 \le M \le 100, \ 1 \le M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。</p>
<p>接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出在规定的时间内可以采到的草药的最大总价值。</p>
<h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>对于 30% 的数据，$M \le 10$</li>
<li>对于全部的数据，$M \le 100$</li>
</ul>
</blockquote>
<p>这是一个典型的0/1背包问题，我们用$x_{i}$表示第$i$种草药采集与否，用$t_{i}$表示采集第$i$种草药所需要的时间，用$m_{i}$表示第$i$种草药的价值，我们的目标是在有限的时间$T$内使采集到的草药价值最大，那么我们就会得到如下的形式化表述:<br>$$\begin{equation}\label{eq1}<br>\begin{aligned}<br>max \ \sum_{i = 1}^{M} x_{i}m_{i} &amp;           \\<br>x_{i}(x_{i}-1) = 0, i \in [1, M]               \\<br>0 \le \sum_{i = 1}^{M}{x_{i}t_{i} \le T}         \\<br>\end{aligned}<br>\end{equation}$$</p>
<p>上面公式中的$x_{i}(x_{i-1})=0$是为了确保$x_{i}$只能取0和1。针对这个问题，我们使用如下的程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> SR1</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> NonlinearConstraint</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> LinearConstraint</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rosen</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;The Rosenbrock function&quot;&quot;&quot;</span></span><br><span class="line">        m = [<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># values</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">            total = x[i] * m[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -total</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the constraints</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cons_f</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [i * (i - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cons_J</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="number">2</span> * x[<span class="number">0</span>] - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span> * x[<span class="number">1</span>] - <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> * x[<span class="number">2</span>] - <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cons_H</span>(<span class="params">x, v</span>):</span></span><br><span class="line">        <span class="keyword">return</span> v[<span class="number">0</span>] * np.array(</span><br><span class="line">            [[<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]) + v[<span class="number">1</span>] * np.array([</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            ]) + v[<span class="number">2</span>] * np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">    nonlinear_constraint = NonlinearConstraint(cons_f, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                                               jac=cons_J,</span><br><span class="line">                                               hess=cons_H)</span><br><span class="line"></span><br><span class="line">    linear_constraint = LinearConstraint([[<span class="number">71</span>, <span class="number">69</span>, <span class="number">1</span>]], [<span class="number">0</span>], [<span class="number">70</span>])</span><br><span class="line"></span><br><span class="line">    x0 = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    res = minimize(rosen,</span><br><span class="line">                   x0,</span><br><span class="line">                   method=<span class="string">&#x27;trust-constr&#x27;</span>,</span><br><span class="line">                   jac=<span class="string">&quot;2-point&quot;</span>,</span><br><span class="line">                   hess=SR1(),</span><br><span class="line">                   constraints=[nonlinear_constraint, linear_constraint],</span><br><span class="line">                   options=&#123;<span class="string">&#x27;verbose&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">barrier_parameter: 2.048000000000001e-09</span><br><span class="line">barrier_tolerance: 2.048000000000001e-09</span><br><span class="line">         cg_niter: 0</span><br><span class="line">     cg_stop_cond: 1</span><br><span class="line">           constr: [array([-0.0073379 ,  0.00693036,  0.0001018 ]), array([70.00010182])]</span><br><span class="line">      constr_nfev: [106, 0]</span><br><span class="line">      constr_nhev: [82, 0]</span><br><span class="line">      constr_njev: [79, 0]</span><br><span class="line">   constr_penalty: 1.0</span><br><span class="line"> constr_violation: 0.0073378956828978265</span><br><span class="line">   execution_time: 0.149078369140625</span><br><span class="line">              fun: 0.00020358301622653028</span><br><span class="line">             grad: array([ 0., -0., -2.])</span><br><span class="line">              jac: [array([[ 0.98521491,  0.        ,  0.        ],</span><br><span class="line">      [ 0.        , -1.01376596,  0.        ],</span><br><span class="line">      [ 0.        ,  0.        , -1.00020358]]), array([[71, 69,  1]])]</span><br><span class="line">  lagrangian_grad: array([-7.48012763e-15, -1.15411153e-14, -2.22470154e-15])</span><br><span class="line">          message: &#39;&#96;xtol&#96; termination condition is satisfied.&#39;</span><br><span class="line">           method: &#39;tr_interior_point&#39;</span><br><span class="line">             nfev: 424</span><br><span class="line">             nhev: 0</span><br><span class="line">              nit: 188</span><br><span class="line">            niter: 188</span><br><span class="line">             njev: 106</span><br><span class="line">       optimality: 1.1541115285673698e-14</span><br><span class="line">           status: 2</span><br><span class="line">          success: True</span><br><span class="line">        tr_radius: 1.0000000000000005e-09</span><br><span class="line">                v: [array([-0.01465935,  0.01384519, -1.99938954]), array([0.00020342])]</span><br><span class="line">                x: array([ 9.92607455e-01, -6.88298061e-03, -1.01791508e-04])</span><br></pre></td></tr></table></figure>
<p>可以看到使用这个求解器并没有得到正确的结果，上面提到的二值约束对这个求解器不是很友好，求解的结果也不满足约束条件。</p>
<h2 id="问题2-连续空间多变量多约束非线性规划问题"><a href="#问题2-连续空间多变量多约束非线性规划问题" class="headerlink" title="问题2: 连续空间多变量多约束非线性规划问题"></a>问题2: 连续空间多变量多约束非线性规划问题</h2><p>$$min \ f(x) = e^{x_{1}}(4x_{1}^{2}+2x_{2}^{2}+4x_{1}x_{2}+2x_{2}+1)$$</p>
<p>$$\begin{equation}\label{eq2}<br>\begin{aligned}<br>1.5 + x_{1}x_{2} -x_{1} - x_{2} &amp;\leq 0          \\<br>-x_{1}x_{2} &amp;\leq 10                           \\<br>-10 \leq x_{1} &amp;\leq 10                       \\<br>-6  \leq x_{2} &amp;\leq 6                        \\<br>\end{aligned}<br>\end{equation}$$</p>
<p>我们先来看一下函数图像，基本上$x, y$越小，函数的值越小。<br><img src="/2020/12/07/optimization_problem/issue2.png" alt="Fig1. 函数图像"><span class="image-caption">Fig1. 函数图像</span></p>
<p>我们使用下面的程序对这个问题进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> Bounds</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> SR1</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> NonlinearConstraint</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.exp(x) * (<span class="number">4</span> * x * x + <span class="number">2</span> * y * y + <span class="number">4</span> * x * y + <span class="number">2</span> * y + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    x = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">    y = np.linspace(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    X, Y = np.meshgrid(x, y)</span><br><span class="line">    Z = f(X, Y)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    ax.plot_surface(X, Y, Z, cmap=<span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rosen</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;The Rosenbrock function&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> math.exp(x[<span class="number">0</span>]) * (<span class="number">4</span> * x[<span class="number">0</span>] * x[<span class="number">0</span>] + <span class="number">2</span> * x[<span class="number">1</span>] * x[<span class="number">1</span>] +</span><br><span class="line">                                 <span class="number">4</span> * x[<span class="number">0</span>] * x[<span class="number">1</span>] + <span class="number">2</span> * x[<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the bound</span></span><br><span class="line">    bounds = Bounds([-<span class="number">10.0</span>, -<span class="number">6.0</span>], [<span class="number">10.0</span>, <span class="number">6.0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the constraints</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cons_f</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1.5</span> + x[<span class="number">0</span>] * x[<span class="number">1</span>] - x[<span class="number">0</span>] - x[<span class="number">1</span>], -x[<span class="number">0</span>] * x[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cons_J</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [[x[<span class="number">1</span>] - <span class="number">1</span>, x[<span class="number">0</span>] - <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cons_H</span>(<span class="params">x, v</span>):</span></span><br><span class="line">        <span class="keyword">return</span> v[<span class="number">0</span>] * np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]) + v[<span class="number">1</span>] * np.array([[<span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">                                                                    [-<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    nonlinear_constraint = NonlinearConstraint(cons_f, [-np.inf, -np.inf],</span><br><span class="line">                                               [<span class="number">0</span>, <span class="number">10</span>],</span><br><span class="line">                                               jac=cons_J,</span><br><span class="line">                                               hess=cons_H)</span><br><span class="line"></span><br><span class="line">    x0 = [<span class="number">0.0</span>, <span class="number">5.0</span>]</span><br><span class="line">    res = minimize(rosen,</span><br><span class="line">                   x0,</span><br><span class="line">                   method=<span class="string">&#x27;trust-constr&#x27;</span>,</span><br><span class="line">                   jac=<span class="string">&quot;2-point&quot;</span>,</span><br><span class="line">                   hess=SR1(),</span><br><span class="line">                   constraints=[nonlinear_constraint],</span><br><span class="line">                   options=&#123;<span class="string">&#x27;verbose&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                   bounds=bounds)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    plot()</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">barrier_parameter: 2.048000000000001e-09</span><br><span class="line">barrier_tolerance: 2.048000000000001e-09</span><br><span class="line">         cg_niter: 529</span><br><span class="line">     cg_stop_cond: 2</span><br><span class="line">           constr: [array([-1.82051237,  9.73411463]), array([-7.68091424,  1.26731198])]</span><br><span class="line">      constr_nfev: [564, 0]</span><br><span class="line">      constr_nhev: [289, 0]</span><br><span class="line">      constr_njev: [288, 0]</span><br><span class="line">   constr_penalty: 1.0</span><br><span class="line"> constr_violation: 0.0</span><br><span class="line">   execution_time: 0.5691990852355957</span><br><span class="line">              fun: 0.0940626469286803</span><br><span class="line">             grad: array([ 0.06804119, -0.01091776])</span><br><span class="line">              jac: [array([[ 0.26731198, -8.68091424],</span><br><span class="line">      [-1.        , -1.        ]]), array([[1., 0.],</span><br><span class="line">      [0., 1.]])]</span><br><span class="line">  lagrangian_grad: array([ 0.00747274, -0.00263313])</span><br><span class="line">          message: &#39;&#96;xtol&#96; termination condition is satisfied.&#39;</span><br><span class="line">           method: &#39;tr_interior_point&#39;</span><br><span class="line">             nfev: 1692</span><br><span class="line">             nhev: 0</span><br><span class="line">              nit: 536</span><br><span class="line">            niter: 536</span><br><span class="line">             njev: 564</span><br><span class="line">       optimality: 0.007472736269283172</span><br><span class="line">           status: 2</span><br><span class="line">          success: True</span><br><span class="line">        tr_radius: 6.8134308785272305e-09</span><br><span class="line">                v: [array([-0.00751795,  0.05714546]), array([-0.00141336,  0.00016742])]</span><br><span class="line">                x: array([-7.68091424,  1.26731198])</span><br></pre></td></tr></table></figure>

<p>初步验证一下，这个结果应该是符合预期的。</p>
<h2 id="问题3-连续空间最值问题"><a href="#问题3-连续空间最值问题" class="headerlink" title="问题3: 连续空间最值问题"></a>问题3: 连续空间最值问题</h2><p>$$\begin{equation}\label{eq3}<br>\begin{aligned}<br>max \ f(x) = 200&amp;e^{-0.05x}sin(x)            \\<br>-2 \le &amp;x \le 2<br>\end{aligned}<br>\end{equation}$$</p>
<p>我们先来看一下函数图像，这个结果比较明显.<br><img src="/2020/12/07/optimization_problem/issue3.png" alt="Fig2. 函数图像"><span class="image-caption">Fig2. 函数图像</span></p>
<p>针对这个问题，我们使用如下的程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> Bounds</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> SR1</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rosen</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The Rosenbrock function&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">200</span> * math.exp(-<span class="number">0.05</span> * x) * math.sin(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span>():</span></span><br><span class="line">    x = np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">    y = [rosen(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">    plt.plot(x, y, color=<span class="string">&quot;r&quot;</span>, linestyle=<span class="string">&quot;-&quot;</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>():</span></span><br><span class="line">    bounds = Bounds([-<span class="number">2.0</span>], [<span class="number">2.0</span>])</span><br><span class="line">    x0 = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    res = minimize(rosen,</span><br><span class="line">                   x0,</span><br><span class="line">                   method=<span class="string">&#x27;trust-constr&#x27;</span>,</span><br><span class="line">                   jac=<span class="string">&quot;2-point&quot;</span>,</span><br><span class="line">                   hess=SR1(),</span><br><span class="line">                   options=&#123;<span class="string">&#x27;verbose&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                   bounds=bounds)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    plot()</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">barrier_parameter: 3.200000000000001e-05</span><br><span class="line">barrier_tolerance: 3.200000000000001e-05</span><br><span class="line">         cg_niter: 9</span><br><span class="line">     cg_stop_cond: 1</span><br><span class="line">           constr: [array([1.52083761])]</span><br><span class="line">      constr_nfev: [0]</span><br><span class="line">      constr_nhev: [0]</span><br><span class="line">      constr_njev: [0]</span><br><span class="line">   constr_penalty: 1.0</span><br><span class="line"> constr_violation: 0.0</span><br><span class="line">   execution_time: 0.08674049377441406</span><br><span class="line">              fun: -185.1242145731396</span><br><span class="line">             grad: array([-5.76906021e-05])</span><br><span class="line">              jac: [&lt;1x1 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span><br><span class="line">       with 1 stored elements in Compressed Sparse Row format&gt;]</span><br><span class="line">  lagrangian_grad: array([7.09417522e-10])</span><br><span class="line">          message: &#39;&#96;gtol&#96; termination condition is satisfied.&#39;</span><br><span class="line">           method: &#39;tr_interior_point&#39;</span><br><span class="line">             nfev: 20</span><br><span class="line">             nhev: 0</span><br><span class="line">              nit: 15</span><br><span class="line">            niter: 15</span><br><span class="line">             njev: 10</span><br><span class="line">       optimality: 7.0941752157368e-10</span><br><span class="line">           status: 1</span><br><span class="line">          success: True</span><br><span class="line">        tr_radius: 24107.414128166944</span><br><span class="line">                v: [array([5.76913115e-05])]</span><br><span class="line">                x: array([1.52083761])</span><br></pre></td></tr></table></figure>
<p>根据图像得知，这个求解结果是正确的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://cloud.tencent.com/developer/article/1099730">https://cloud.tencent.com/developer/article/1099730</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">https://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/01/30/pack_issue/</url>
    <content><![CDATA[<p>背包问题是动态规划的一种，其主要的分类和解法请参考</p>
<div class="pdfobject-container" data-target="/resources/pack_issue.pdf" data-height="500px"></div>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://raw.githubusercontent.com/tianyicui/pack/master/V2.pdf">https://raw.githubusercontent.com/tianyicui/pack/master/V2.pdf</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>pack issue</tag>
      </tags>
  </entry>
  <entry>
    <title>随机算法</title>
    <url>/2020/12/03/random_algorithm/</url>
    <content><![CDATA[<h2 id="问题1-拒绝采样"><a href="#问题1-拒绝采样" class="headerlink" title="问题1: 拒绝采样"></a>问题1: 拒绝采样</h2><h3 id="leetcode-470-Implement-Rand10-Using-Rand7"><a href="#leetcode-470-Implement-Rand10-Using-Rand7" class="headerlink" title="leetcode 470: Implement Rand10() Using Rand7()"></a><a href="https://leetcode.com/problems/implement-rand10-using-rand7/">leetcode 470: Implement Rand10() Using Rand7()</a></h3><blockquote>
<p>Given the <strong>API</strong> rand7() that generates a uniform random integer in the range [1, 7], write a function rand10() that generates a uniform random integer in the range [1, 10]. You can only call the API rand7(), and you shouldn’t call any other API. Please do not use a language’s built-in random API.</p>
<p>Each test case will have one internal argument n, the number of times that your implemented function rand10() will be called while testing. Note that this is not an argument passed to rand10().</p>
<p>Follow up:<br>What is the expected value for the number of calls to rand7() function?<br>Could you minimize the number of calls to rand7()?</p>
<p>Example 1:<br>Input: n = 1<br>Output: [2]</p>
<p>Example 2:<br>Input: n = 2<br>Output: [2,8]</p>
<p>Example 3:<br>Input: n = 3<br>Output: [3,8,10]</p>
<p>Constraints:<br>1 &lt;= n &lt;= 105</p>
</blockquote>
<p><img src="/2020/12/03/random_algorithm/table.png" alt="Fig 1. 二维随机表格分布"><span class="image-caption">Fig 1. 二维随机表格分布</span></p>
<p>我们可以使用“拒绝采样”来求解这个题目。 注意rand10要求返回的数字在[1, 10]之间均匀分布。执行一次rand7()只能得到[1, 7]之间的均匀分布，我们可以执行两次rand7(), 将两次的执行结果看做表格的横纵坐标(row, col)，这时候表格中的每一个单元被选中的机会是相等的, 这样我们就得到了一个二维表格中的均匀分布。接下来， 我们将这个二维坐标转换为一维坐标，我们就得到了[1, 49]之间的均匀分布。我们的最终目标是得到[1, 10]之间的均匀分布，由于可以把[1, n * 10]之间的均匀分布通过取余预算转换为[1, 10]之间的均匀分布，所以这里我们取[1, 40]为有效值，当获取的值不在这个范围时候，我们重新采样。这个过程即拒绝采样。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> row = rand7();</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> col = rand7();</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> idx = (row - <span class="number">1</span>) * <span class="number">7</span> + col;</span><br><span class="line">      <span class="keyword">if</span> (idx &lt;= <span class="number">40</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> idx % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> rand10();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="问题2：抽水采样"><a href="#问题2：抽水采样" class="headerlink" title="问题2：抽水采样"></a>问题2：抽水采样</h2><h3 id="leetcode-398-Random-Pick-Index"><a href="#leetcode-398-Random-Pick-Index" class="headerlink" title="leetcode 398: Random Pick Index"></a><a href="https://leetcode.com/problems/random-pick-index/">leetcode 398: Random Pick Index</a></h3><blockquote>
<p>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p>
<p>Note:<br>The array size can be very large. Solution that uses too much extra space will not pass the judge.</p>
<p>Example:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Solution solution = <span class="keyword">new</span> Solution(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pick(3) should return either index 2, 3, or 4 randomly.</span></span><br><span class="line"><span class="comment">// Each index should have equal probability of returning.</span></span><br><span class="line">solution.pick(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pick(1) should return 0. Since in the array only nums[0] is equal to 1.</span></span><br><span class="line">solution.pick(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们可以使用“<a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3">抽水采样</a>”来求解这个题目。我们先给出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums): data(nums) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == target) &#123;</span><br><span class="line">                ++num;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> r = rand() % num; <span class="comment">// value in [0, num - 1]</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    res = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是一个具体分析：</p>
<ol>
<li>如果target只出现了1次，那么<code>rand() % num</code>等于0，这个index一定会被返回；</li>
<li>如果target出现了2次，第一个index被选中的概率是：<code>100% * 50% = 50%</code>；第二个index被选中的概率是<code>50%</code>，它们是被均匀采样的；</li>
<li>如果target出现了3次，那么它的3个index被返回的概率分别是：<ul>
<li><code>100% * (1 - 50%) * (1 - 33.33%) = 33.33%</code>，第一步被选中，第二步和第三步没有被换掉；</li>
<li><code>50% * (1 - 33.33%) = 33.33%</code>，第二步被选中，第三步没有被换掉；</li>
<li><code>33.33%</code>，第三步被选中；</li>
</ul>
</li>
</ol>
<p>以此类推，可以保证每个index被选中的概率是相等的。</p>
<h2 id="问题3-C-获取随机数"><a href="#问题3-C-获取随机数" class="headerlink" title="问题3: C++获取随机数"></a>问题3: C++获取随机数</h2><h3 id="rand"><a href="#rand" class="headerlink" title="rand()"></a><a href="https://en.cppreference.com/w/cpp/numeric/random/rand">rand()</a></h3><p>Returns a pseudo-random integral value between 0 and RAND_MAX. And 0 and RAND_MAX included.</p>
<h3 id="uniform-int-distribution"><a href="#uniform-int-distribution" class="headerlink" title="uniform_int_distribution"></a><a href="https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution">uniform_int_distribution</a></h3><p>Produces random integer values i, uniformly distributed on the closed interval [a, b].</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Will be used to obtain a seed for the random number engine.</span></span><br><span class="line">  <span class="built_in">std</span>::random_device rd;</span><br><span class="line">  <span class="comment">// Standard mersenne_twister_engine seeded with rd().</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">distrib</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distrib(gen) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>random</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟退火</title>
    <url>/2020/12/13/simulated_annealing/</url>
    <content><![CDATA[<p>模拟退火是一种通用概率算法，常用来在一定时间内寻找在一个很大搜寻空间中的近似最优解。和爬山算法相比，模拟退火算法以一定的概率接受不好的迭代，从而跳出局部最优。</p>
<p>下面我们尝试使用模拟退火算法来解决<a href="https://leehengtong.com/2020/12/07/optimization_problem/">上篇文章</a>中的几个问题：</p>
<h2 id="问题1-离散空间优化问题"><a href="#问题1-离散空间优化问题" class="headerlink" title="问题1: 离散空间优化问题"></a>问题1: 离散空间优化问题</h2><p>我们使用以下程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neighbor</span>(<span class="params">last, T, t</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    returns a neighbor</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># compute used time</span></span><br><span class="line">    time = <span class="keyword">lambda</span> cur: <span class="built_in">sum</span>([cur[i] * t[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = [i <span class="keyword">for</span> i <span class="keyword">in</span> last]</span><br><span class="line">        idx = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(last) - <span class="number">1</span>)</span><br><span class="line">        res[idx] = <span class="number">1</span> - res[idx]</span><br><span class="line">        <span class="keyword">if</span> time(res) &lt;= T:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">T, M, t, m</span>):</span></span><br><span class="line">    <span class="comment"># compute the value got</span></span><br><span class="line">    value = <span class="keyword">lambda</span> cur: <span class="built_in">sum</span>([cur[i] * m[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M)])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># temperature setting</span></span><br><span class="line">    cur_tmp = <span class="number">100</span></span><br><span class="line">    tmp_fin = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># valid init solution</span></span><br><span class="line">    ans = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    val = value(ans)</span><br><span class="line">    <span class="keyword">while</span> cur_tmp &gt; tmp_fin:</span><br><span class="line">        <span class="comment"># get a neighbor</span></span><br><span class="line">        <span class="built_in">next</span> = neighbor(ans, T, t)</span><br><span class="line">        next_value = value(<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        diff = next_value - val</span><br><span class="line">        r = random.random()</span><br><span class="line">        <span class="keyword">if</span> next_value &gt; val <span class="keyword">or</span> r &lt; math.exp(-<span class="built_in">abs</span>(diff) / cur_tmp):</span><br><span class="line">            ans = <span class="built_in">next</span></span><br><span class="line">            val = next_value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update the temperature</span></span><br><span class="line">        cur_tmp = cur_tmp * <span class="number">0.999</span></span><br><span class="line"></span><br><span class="line">    print(ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    T = <span class="number">70</span></span><br><span class="line">    M = <span class="number">3</span></span><br><span class="line">    t = [<span class="number">71</span>, <span class="number">69</span>, <span class="number">1</span>]</span><br><span class="line">    m = [<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    solve(T, M, t, m)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0, 1, 1]</span><br></pre></td></tr></table></figure>


<h2 id="问题2-连续空间多变量多约束非线性规划问题"><a href="#问题2-连续空间多变量多约束非线性规划问题" class="headerlink" title="问题2: 连续空间多变量多约束非线性规划问题"></a>问题2: 连续空间多变量多约束非线性规划问题</h2><p>我们使用以下程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    check the constraint</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">6</span> <span class="keyword">or</span> i &lt; -<span class="number">6</span> <span class="keyword">or</span> i &gt; <span class="number">10</span> <span class="keyword">or</span> i &lt; -<span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> -x[<span class="number">0</span>] * x[<span class="number">1</span>] &gt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1.5</span> + x[<span class="number">0</span>] * x[<span class="number">1</span>] - x[<span class="number">0</span>] - x[<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neighbor</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    returns a neighbor</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = [i <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">        r1 = random.random()</span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> r1 &gt; <span class="number">0.5</span>:</span><br><span class="line">            idx = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        r2 = random.random()</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r2 &gt; <span class="number">0.5</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        r3 = random.random()</span><br><span class="line">        res[idx] = res[idx] + sign * r3</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> constrain(res):</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    the target function</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> math.exp(</span><br><span class="line">        x[<span class="number">0</span>]) * (<span class="number">4</span> * x[<span class="number">0</span>]**<span class="number">2</span> + <span class="number">2</span> * x[<span class="number">1</span>]**<span class="number">2</span> + <span class="number">4</span> * x[<span class="number">0</span>] * x[<span class="number">1</span>] + <span class="number">2</span> * x[<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>():</span></span><br><span class="line">    <span class="comment"># temperature setting</span></span><br><span class="line">    cur_tmp = <span class="number">100</span></span><br><span class="line">    tmp_fin = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># valid init solution</span></span><br><span class="line">    ans = [<span class="number">0</span>, <span class="number">5</span>]</span><br><span class="line">    val = func(ans)</span><br><span class="line">    <span class="keyword">while</span> cur_tmp &gt; tmp_fin:</span><br><span class="line">        <span class="comment"># get a neighbor</span></span><br><span class="line">        <span class="built_in">next</span> = neighbor(ans)</span><br><span class="line">        next_value = func(<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        diff = next_value - val</span><br><span class="line">        r = random.random()</span><br><span class="line">        <span class="keyword">if</span> next_value &lt; val <span class="keyword">or</span> r &lt; math.exp(-<span class="built_in">abs</span>(diff) / cur_tmp):</span><br><span class="line">            ans = <span class="built_in">next</span></span><br><span class="line">            val = next_value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update the temperature</span></span><br><span class="line">        cur_tmp = cur_tmp * <span class="number">0.999</span></span><br><span class="line"></span><br><span class="line">    print(ans)</span><br><span class="line">    print(func(ans))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[-5.976946429765198, 1.5103517825203914]</span><br><span class="line">0.2926414515330139</span><br></pre></td></tr></table></figure>
<p>用相同的初始值，模拟退火算法得到了更好的结果。</p>
<h2 id="问题3-连续空间最值问题"><a href="#问题3-连续空间最值问题" class="headerlink" title="问题3: 连续空间最值问题"></a>问题3: 连续空间最值问题</h2><p>我们使用以下程序进行求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    the target function</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">200</span> * math.exp(-<span class="number">0.05</span> * x[<span class="number">0</span>]) * math.sin(x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constrain</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    check the constraint</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">0</span>] &gt;= -<span class="number">2</span> <span class="keyword">and</span> x[<span class="number">0</span>] &lt;= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neighbor</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    returns a neighbor</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = [i <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">        r1 = random.random()</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r1 &gt; <span class="number">0.5</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        r2 = random.random()</span><br><span class="line">        res[<span class="number">0</span>] = res[<span class="number">0</span>] + sign * r2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> constrain(res):</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>():</span></span><br><span class="line">    <span class="comment"># temperature setting</span></span><br><span class="line">    cur_tmp = <span class="number">100</span></span><br><span class="line">    tmp_fin = <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># valid init solution</span></span><br><span class="line">    ans = [<span class="number">0</span>]</span><br><span class="line">    val = func(ans)</span><br><span class="line">    <span class="keyword">while</span> cur_tmp &gt; tmp_fin:</span><br><span class="line">        <span class="comment"># get a neighbor</span></span><br><span class="line">        <span class="built_in">next</span> = neighbor(ans)</span><br><span class="line">        next_value = func(<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        diff = next_value - val</span><br><span class="line">        r = random.random()</span><br><span class="line">        <span class="keyword">if</span> next_value &lt; val <span class="keyword">or</span> r &lt; math.exp(-<span class="built_in">abs</span>(diff) / cur_tmp):</span><br><span class="line">            ans = <span class="built_in">next</span></span><br><span class="line">            val = next_value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update the temperature</span></span><br><span class="line">        cur_tmp = cur_tmp * <span class="number">0.999</span></span><br><span class="line"></span><br><span class="line">    print(ans)</span><br><span class="line">    print(func(ans))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1.530673326410524]</span><br><span class="line">-185.11524120724246</span><br></pre></td></tr></table></figure>


<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB">https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB</a></li>
<li><a href="https://en.wikipedia.org/wiki/Simulated_annealing">https://en.wikipedia.org/wiki/Simulated_annealing</a></li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>simulated annealing</tag>
      </tags>
  </entry>
</search>
